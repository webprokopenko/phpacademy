<?php
/**
 * Created by PhpStorm.
 * User: 0311
 * Date: 03.05.2017
 * Time: 8:21 AM
 */
/**
 * Функции помогают создавать структурированный код, пригодный для повтор-
ного использования. Они позволяют абстрагироваться от второстепенных под-
робностей, делая код более гибким и понятным. Без использования функций
программы создают массу проблем с сопровождением, потому что вам приходит-
ся постоянно обновлять идентичные блоки кода в разных местах и разных файлах.
Функция объявляется ключевым словом function, за которым следует имя функ-
ции и параметры, заключенные в круглые скобки. Чтобы вызвать функцию,
просто укажите ее имя и значения аргументов. Если функция возвращает значе-
ние, присвойте результат функции переменной.
Предварительно объявлять функцию перед вызовом не обязательно. PHP об-
рабатывает весь файл, прежде чем выполнять его, поэтому объявления и вызовы
функций можно чередовать в любой последовательности. При этом в PHP нель-
зя переопределять функции. Обнаружив функцию с именем, идентичным имени
уже существующей функции, PHP выдает фатальную ошибку и аварийно за-
вершается.
Иногда стандартная процедура с передачей фиксированного количества аргу-
ментов и возвращением одного значения плохо подходит для конкретной ситу-
ации в вашем коде. Возможно, вы не знаете заранее, сколько параметров потре-
буется вашей функции. А может быть, функция почти всегда вызывается
с одними и теми же значениями параметров, и вам не хочется загромождать код
лишней информацией. А может, из функции нужно вернуть более одного значе-
ния.
 */
/**
 * Обращение к параметрам функции
 * Требуется получить доступ к значениям, переданным функции
 */
function commercial_sponsorship($letter, $number){
    print "This episode of Sesame Street is brought to you by ";
    print "the letter $letter and number $number. <br>";
}
commercial_sponsorship("G",13);
/**
PHP создает копию переданного зна-
чения и предоставляет ее вашему коду для дальнейшей работы. Изменения,
вносимые в копию, не отражаются на исходном значении. Например, функция:
 */
function add_one($number){
    $number++;
}
$number = 1;
add_one($number);
print $number."<br>";
/**
 * Если бы переменная передавалась по ссылке, то значение $number в глобальной
области действия было бы равно 2.
Во многих языках передача переменных по ссылке обладает дополнительным
преимуществом: она работает заметно быстрее, чем передача по значению. Хотя
в PHP передача по ссылке тоже выполняется быстрее, различия в скорости не-
велики. По этой причине рекомендую передавать переменные по ссылке
только тогда, когда это действительно необходимо, и никогда не применять пере-
дачу по ссылке в целях оптимизации.
 */

/**
 * Определение значений по умолчанию для параметров функции
 */
/**
Параметр должен иметь значение по умолчанию, если иное значение не указы-
вается при вызове функции. Например, функция для заключения текста в теги
HTML может иметь параметр для имени тега; если его значение не задано, по
умолчанию используется тег strong.
 */
function wrap_in_html_tag($text, $tag = 'strong'){
    return "<$tag>$text</$tag>";
}
echo wrap_in_html_tag('HELLO WORLD')."<br>";
echo wrap_in_html_tag('HELLO WORLD','em')."<br>";
/**
 * При присваивании значений по умолчанию следует помнить о двух важных об-
стоятельствах. Во-первых, все параметры со значениями по умолчанию должны
перечисляться после параметров, не имеющих значений по умолчанию. В про-
тивном случае PHP не сможет определить, какие параметры не были указаны
при вызове, в каких случаях следует взять значение по умолчанию, а какие аргу-
менты переопределяют его. Следовательно, функция wrap_in_html_tag() не
может быть определена так:
function wrap_in_html_tag($tag = 'strong', $text)
Если вы поступите так и передадите wrap_in_html_tag() только один аргумент,
то PHP присвоит значение $tag и выдаст предупреждение об отсутствии второ-
го аргумента.
 * Во-вторых, присваиваемое значение по умолчанию должно быть константой,
например строкой или числом. Оно не может быть переменной. Возвращаясь
к примеру wrap_in_html_tag(), следующее объявление недопустимо:

$my_favorite_html_tag = 'blink';
function wrap_in_html_tag($text, $tag = $my_favorite_html_tag) {
    return "<$tag>$text</$tag>";
}
Если по умолчанию переменная не должна содержать ничего, можно присвоить
параметру пустую строку:
function wrap_in_html_tag($text, $tag = '') {
if (empty($tag)) { return $text; }
    return "<$tag>$text</$tag>";
}
Если значение $tag не передается, функция возвращает исходную строку. Если
передается непустое имя тега, то возвращается строка, заключенная между соот-
ветствующими тегами.
 */

/**
 * Передача по ссылке
 * Требуется передать переменную функции так, чтобы
 * в ней сохранились все изменения, внесенные в ее значение
 * внутри функции.
 * Чтобы аргумент передавался функции по ссылке, а не по значению, поставьте
 * знак & перед именем параметра в прототипе функции:
 */
function wrap_in_html_tag2(&$text, $tag = 'strong'){
    $text = "<$tag>$text</$tag>";
}
$text = 'Hello text';
wrap_in_html_tag2($text);
echo $text;
/**
если параметр объявлен для передачи по ссылке, в нем нельзя пере-
дать константу (строку, число и т. д.); в противном случае происходит аварийное
завершение с фатальной ошибкой.
 */
define('TEXT_TO','HELLO TEXT');

/**
 * Именованные параметры
 * Задача: Требуется передать аргументы функции по имени (а не по их позиции в списке при вызове функции)
 */
/**
 * В PHP нет встроенной поддержки именованных параметров, в отличие от не-
которых других языков. Однако эту поддержку можно смоделировать, передавая
функции один параметр, который представляет собой ассоциативный массив:
 */
function image(array $img){
    $tag = '<img src="' .$img['src']. '">';
    $tag .= 'alt="' . (isset($img['alt']) ? $img['alt'] : '') .'"/>';
    return $tag;
}
$image1 = image(array('src' => 'cow.png', 'alt' => 'cows say moo'));
// $image2 содержит '<img src="pig.jpeg" alt=""/>'
$image2 = image(array('src' => 'pig.jpeg'));
/**
Хотя именованные параметры усложняют код внутри функций, они упрощают
код вызова этих функций. Так как код функции находится в одном месте, а вы-
зывается во многих, программа становится более понятной.
Так как параметры функции выделены в ассоциативный массив, PHP не сможет
предупредить о случайной опечатке в имени параметра. Вам придется действовать
более осторожно, потому что парсер не обнаруживает такие ошибки. Кроме того,
вы не сможете воспользоваться возможностью определения значения по умол-
чанию для параметра. К счастью, этот недостаток можно обойти, добавив простой
код в начало функции:
 */
function image2($img) {
    if (! isset($img['src'])) { $img['src'] = 'cow.png'; }
    if (! isset($img['alt'])) { $img['alt'] = 'milk factory'; }
    if (! isset($img['height'])) { $img['height'] = 100; }
    if (! isset($img['width'])) { $img['width'] = 50; }
    $tag = '<img src="' .$img['src']. '">';
    $tag .= 'alt="' . $img['alt'] .'"/>';
}
/**
 * При помощи функции isset() вы убеждаетесь в том, что значение каждого па-
раметра определено; в противном случае параметру присваивается значение по
умолчанию.
Также желаемого результата можно добиться при помощи функции array_
merge():
 */
function image3($img) {
    $defaults = array('src' => 'cow.png',
        'alt' => 'milk factory',
        'height' => 100,
        'width' => 50
    );
    $img = array_merge($defaults, $img);
    /* ... */
}
/**
 * Если один ключ присутствует в обоих массивах, переданных array_merge(), то
используется значение из второго массива. В приведенном примере это означает,
что все значения из $img переопределят значения из $defaults. Если ключ от-
сутствует в $img, то используется значение из $defaults.
 */
/**
 * Контроль типа аргументов
 * Требуется проследить за тем, чтобы значения аргументов относились к опреде-
ленным типам.
Используйте указания типов для параметров в определении функции. Указание
типа размещается перед именем параметра в объявлении функции:
Указание типа может быть именем класса, именем интерфейса, ключевым словом
array (начиная с PHP 5.1) или ключевым словом callable (начиная с PHP 5.4).
Если во время выполнения для параметра с указанием типа передается значение,
не соответствующее указанию, PHP выдает ошибку E_RECOVERABLE_ERROR.
Если назначить параметру с указанием типа значение по умолчанию null, то этот
параметр может принимать значение null или значение соответствующего типа.
В следующем коде функция must_be_an_array() требует, чтобы ей передавался
параметр-массив. Во всех остальных случаях выдается ошибка E_RECOVERABLE_
ERROR. Функция array_or_null_is_ok() устанавливает менее жесткие требова-
ния — если ей передается параметр, то он должен содержать массив или null.
Если параметр не задан, то локальная переменная $fruits будет равна null:
 */
function drink_juice(EmptyIterator $drink) {
    /* ... */
}
function enumerate_some_stuff(array $values) {
    /* ... */
}

/**
Функции call_user_func() и call_user_func_array() несколько отличаются от
стандартных функций PHP. В первом аргументе передается не выводимая стро-
ка и не суммируемое число, а имя выполняемой функции. Концепция передачи
имени функции для вызова иногда называется обратным вызовом (callback).
Функция call_user_func_array() весьма удобна при обратном вызове из функ-
ции, которая может получать переменное количество аргументов. В таких ситу-
ациях вместо того, чтобы встраивать логику внутрь функции, можно получить
все аргументы при помощи func_get_args():
 */
function cal_test(callable $func){
    call_user_func($func);
}

cal_test(function(){echo "Callable function test!!";});

$test_fun = function($text="Test text"){
    echo "$text<br>";
};
function cal_test2(callable $func,$text){
    call_user_func($func,$text);
}
cal_test2($test_fun,"NEW TEXT TEST");

function must_be_an_array(array $fruits) {
    foreach ($fruits as $fruit) {
        print "$fruit\n";
    }
}
function array_or_null_is_ok(array $fruits = null) {
    if (is_array($fruits)) {
        foreach ($fruits as $fruit) {
            print "$fruit\n";
        }
    }
}
/**
 * Создание функций с переменным количеством аргументов
 * Задача : Требуется определить функцию которая может получать переменное количество аргументов
 * Решение №1
 */
function mean($numbers){
    $sum = 0;
    $size = count($numbers);

    for ($i=0;$i<$size;$i++){
        $sum += $numbers[$i];
    }
    $average = $sum / $size;

    return $average;
}

$mean = mean(array(83,91,32,1));
echo $mean;
/**
 * * Решение №2
 * В этом примере используются функции для получения информации об аргумен-
тах, переданных функции, из которой они вызываются. Функция func_num_args()
возвращает количество аргументов, переданных вызывающей функции — в дан-
ном случае функции mean(). Далее функция func_get_arg() используется для
получения конкретного значения аргумента для каждой позиции.
Для вызова mean(96, 93, 98, 98) функция func_num_args() возвращает 4. Пер-
вый аргумент находится в позиции 0, поэтому перебор осуществляется от 0 до 3,
а не от 1 до 4 (поэтому в цикле for переменная $i изменяется от 0 до значения,
меньшего $size). Как видите, логика аналогична той, которая использовалась
в Решении с передачей массива. Не беспокойтесь о потенциальной неэффектив-
ности вызова func_get_arg() в цикле — на самом деле этот способ работает бы-
стрее, чем вариант с передачей массива.
 */

function mean2(){
    $sum = 0;
    //Аргументы, переданные функции
    $size = func_num_args();
    for ($i = 0; $i < $size; $i++){
        $sum += func_get_arg($i);
    }
    return $average = $sum / $size;
}
echo $mean = mean2(96,32,33);
/**
 * Решение №3
 * Третья версия этой функции использует func_get_args() для получения масси-
ва со всеми значениями, переданными функции. Она представляет собой гибрид
предыдущих двух версий
Такое решение не требует лишнего места для хранения чисел во временном мас-
сиве при передаче их mean(), но внутри функции код продолжает работать с ними
так, словно числа хранятся в массиве.
 */
function mean3(){
    $sum = 0;
    $size = func_num_args();
    foreach (func_get_args() as $arg) {
        $sum += $arg;
    }
    $average = $sum / $size;
    return $average;
}

function mean4($arg1="",$arg2=null){
    $size = func_num_args();
    echo $size;
    foreach (func_get_args() as $key=>$arg) {
        echo "key: ".$key." value: ".$arg. "<br>";
    }
}
echo "<br>";
mean4('test1','test2','test3');

function mean5($arg1='',$arg2=null){
    echo $arg1;
    echo "<br>";
    echo $arg2;
    //echo $arg3;
}
mean5();

/**
 * Возвращение значений по ссылке
 * Задача: Требуется вернуть значение по ссылке, а не по значению.
 * Тем самым предотвращается создание лишнего дубликата переменной.
 */
function &array_find_value($needle,&$haystack){
    foreach ($haystack as $key => $value) {
        if ($needle == $value)
            return $haystack[$key];
    }
}
$minnesota = array('Bob Dylan', 'F. Scott Fitzegerald','Prince', 'Charles');
$prince = &array_find_value('Prince',$minnesota);

$prince = 'New Prince';
var_dump($minnesota);
/**
 * При возвращении значения по ссылке из функции должна возвращаться ссылка
на переменную, а не строка. Например, следующая реализация недопустима:
 * Дело в том, что "$match is found in position $key" является строкой, а воз-
вращение ссылки на нечто, не являющееся переменной, не имеет смысла. PHP
выдает ошибку E_NOTICE.
 */
function &array_find_value2($needle, &$haystack) {
    foreach ($haystack as $key => $value) {
        if ($needle == $value) {
            $match = $haystack[$key];
        }
    }
    return "$match is found in position $key";
}
$prince2 = &array_find_value2('New Prince',$minnesota);
var_dump($prince2);
/**
 * Возвращение нескольких значений из функции
 * Задача: Требуется вернуть из функции более одного значения.
 * Решение №1
 */
function array_stats($values){
    $min = min($values);
    $max = max($values);
    $mean = array_sum($values) / count($values); #array_sum — Вычисляет сумму значений массива

    return array($min,$max,$mean);
}
$values = array(1,3,4,5,18,21,16,33);
$ar = array_stats($values);
list($min,$max,$mean) = $ar;
echo "MIN: ".$min."<br>";
echo "MAX: ".$max."<br>";
echo "MEAN: ".$mean."<br>";
/**
 * * Решение №2
 * Одна из альтернатив — передача значений по ссылке. Однако такое решение
может показаться неуклюжим и противоестественным, потому что передача не-
обходимых переменных функции не всегда выглядит логично. Пример:
 */
function time_parts($time, &$hour, &$minute, &$second) {
    list($hour, $minute, $second) = explode(':', $time);
}
time_parts('12:34:56', $hour, $minute, $second);

echo $hour."<br>";
/**
 * Решение №3
 * Также можно использовать глобальные переменные, но они загромождают гло-
бальное пространство имен, а вы вряд ли сразу поймете, какие переменные неза-
метно изменяются функцией.
 */
function time_parts_global($time) {
    global $hours, $minutes, $seconds;
    list($hours, $minutes, $seconds) = explode(':', $time);
}
time_parts_global('12:34:56');
echo $hours."<br>";
echo $minutes."<br>";
echo $seconds."<br>";
/**
 * Обращение к глобальной переменной внутри функции
 */
function eat_fruit($fruit) {
    global $chew_count;
    $chew_count = 15;
    for ($i = $chew_count; $i > 0; $i--) {
        /* ... */
    }
}


eat_fruit('fr'); # будет работать только после вызова функции. если обратиться до того как вызвана функция - будет ошибка
echo $GLOBALS['chew_count'];

/**
 * Пропуск отдельных возвращаемых значений
 * Задача: Функция возвращает несколько значений,
 * но Вас интересуют только некоторые из них
 */
function time_parts2($time){
    return explode(':',$time);
}
list(,$minutee,) = time_parts2('12:44:21');
echo "<b>".$minutee;

/**
 * Возвращение признака ошибки
 * Задача: Требуется вернуть из функции признак ошибки, то есть неудачного выполнения
 */
function lookup($name){
    if (empty($name)) return false;
    /**
     * Какой то код
     */
}
if (false !== lookup('Jack')){
    /**
     * Поиск прошел успешно
     */
} else {
    /**
     * Сохранить информацию об ошибке
     */
}
/**
 * Обращение к глобальной переменной внутри функции
 */
$food = 'pizza';
$drink = 'beer';
function party() {
    global $food, $drink;
    unset($food); // Съесть пиццу
    //$drink = 'New Drink';
    unset($GLOBALS['drink']); // Выпить пиво
}
print "$food: $drink\n";
party();
print "$food: $drink\n";

/**
 * Создание динамических функций
 * Требуется создать и определить функцию во время выполнения программы
 */
$add = function($i,$j){
    return $i + $j;
};
echo "<br>".$add(16,2);
$imcrement1 = 7;
$imcrement2 = 10;
$add2 = function ($i,$j) use ($imcrement1,$imcrement2){
    return $i + $j + $imcrement1 + $imcrement2;
};
echo "<br>".$add2(2,2);
/**
 * Второй вариант использования динамичесокй функции
 */

$imcrement3 = 10;
$add3 = create_function('$i,$j','return $i+$j+'.$imcrement3.';');
echo $add3(10,10);
